var e = require("./7832a774.js");

var r = require("@urql/core");

var a = {
  __typename: "PageInfo",
  endCursor: null,
  startCursor: null,
  hasNextPage: !1,
  hasPreviousPage: !1
};

function ensureKey(e) {
  return "string" == typeof e ? e : null;
}

function concatEdges(e, r, a) {
  var n = new Set;
  for (var t = 0, s = r.length; t < s; t++) {
    var o = e.resolve(r[t], "node");
    if ("string" == typeof o) {
      n.add(o);
    }
  }
  var i = r.slice();
  for (var f = 0, u = a.length; f < u; f++) {
    var v = a[f];
    var l = e.resolve(v, "node");
    if ("string" == typeof l && !n.has(l)) {
      n.add(l);
      i.push(v);
    }
  }
  return i;
}

function concatNodes(e, r) {
  var a = new Set;
  for (var n = 0, t = e.length; n < t; n++) {
    var s = e[n];
    if ("string" == typeof s) {
      a.add(s);
    }
  }
  var o = e.slice();
  for (var i = 0, f = r.length; i < f; i++) {
    var u = r[i];
    if ("string" == typeof u && !a.has(u)) {
      a.add(u);
      o.push(u);
    }
  }
  return o;
}

function compareArgs(e, a) {
  for (var n in a) {
    if ("first" === n || "last" === n || "after" === n || "before" === n) {
      continue;
    } else if (!(n in e)) {
      return !1;
    }
    var t = e[n];
    var s = a[n];
    if (typeof t != typeof s || "object" != typeof t ? t !== s : r.stringifyVariables(t) !== r.stringifyVariables(s)) {
      return !1;
    }
  }
  for (var o in e) {
    if ("first" === o || "last" === o || "after" === o || "before" === o) {
      continue;
    }
    if (!(o in a)) {
      return !1;
    }
  }
  return !0;
}

function getPage(e, r, n) {
  var t = ensureKey(e.resolve(r, n));
  if (!t) {
    return null;
  }
  var s = e.resolve(t, "__typename");
  var o = e.resolve(t, "edges") || [];
  var i = e.resolve(t, "nodes") || [];
  if ("string" != typeof s) {
    return null;
  }
  var f = {
    __typename: s,
    edges: o,
    nodes: i,
    pageInfo: a
  };
  var u = e.resolve(t, "pageInfo");
  if ("string" == typeof u) {
    var v = ensureKey(e.resolve(u, "__typename"));
    var l = ensureKey(e.resolve(u, "endCursor"));
    var g = ensureKey(e.resolve(u, "startCursor"));
    var c = e.resolve(u, "hasNextPage");
    var d = e.resolve(u, "hasPreviousPage");
    var p = f.pageInfo = {
      __typename: "string" == typeof v ? v : "PageInfo",
      hasNextPage: "boolean" == typeof c ? c : !!l,
      hasPreviousPage: "boolean" == typeof d ? d : !!g,
      endCursor: l,
      startCursor: g
    };
    if (null === p.endCursor) {
      var y = o[o.length - 1];
      if (y) {
        var m = e.resolve(y, "cursor");
        p.endCursor = ensureKey(m);
      }
    }
    if (null === p.startCursor) {
      var h = o[0];
      if (h) {
        var P = e.resolve(h, "cursor");
        p.startCursor = ensureKey(P);
      }
    }
  }
  return f;
}

exports.relayPagination = function relayPagination(r) {
  if (void 0 === r) {
    r = {};
  }
  var n = r.mergeMode || "inwards";
  return function(r, t, s, o) {
    var i = o.parentKey;
    var f = o.fieldName;
    var u = s.inspectFields(i).filter((function(e) {
      return e.fieldName === f;
    }));
    var v = u.length;
    if (0 === v) {
      return;
    }
    var l = null;
    var g = [];
    var c = [];
    var d = [];
    var p = [];
    var y = e._extends({}, a);
    for (var m = 0; m < v; m++) {
      var h = u[m];
      var P = h.fieldKey;
      var _ = h.arguments;
      if (null === _ || !compareArgs(t, _)) {
        continue;
      }
      var N = getPage(s, i, P);
      if (null === N) {
        continue;
      }
      if ("inwards" === n && "number" == typeof _.last && "number" == typeof _.first) {
        var C = N.edges.slice(0, _.first + 1);
        var b = N.edges.slice(-_.last);
        var I = N.nodes.slice(0, _.first + 1);
        var K = N.nodes.slice(-_.last);
        g = concatEdges(s, g, C);
        c = concatEdges(s, b, c);
        d = concatNodes(d, I);
        p = concatNodes(K, p);
        y = N.pageInfo;
      } else if (_.after) {
        g = concatEdges(s, g, N.edges);
        d = concatNodes(d, N.nodes);
        y.endCursor = N.pageInfo.endCursor;
        y.hasNextPage = N.pageInfo.hasNextPage;
      } else if (_.before) {
        c = concatEdges(s, N.edges, c);
        p = concatNodes(N.nodes, p);
        y.startCursor = N.pageInfo.startCursor;
        y.hasPreviousPage = N.pageInfo.hasPreviousPage;
      } else if ("number" == typeof _.last) {
        c = concatEdges(s, N.edges, c);
        p = concatNodes(N.nodes, p);
        y = N.pageInfo;
      } else {
        g = concatEdges(s, g, N.edges);
        d = concatNodes(d, N.nodes);
        y = N.pageInfo;
      }
      if (N.pageInfo.__typename !== y.__typename) {
        y.__typename = N.pageInfo.__typename;
      }
      if (l !== N.__typename) {
        l = N.__typename;
      }
    }
    if ("string" != typeof l) {
      return;
    }
    if (!!!ensureKey(s.resolve(i, f, t))) {
      if (!o.store.schema) {
        return;
      } else {
        o.partial = !0;
      }
    }
    return {
      __typename: l,
      edges: "inwards" === n ? concatEdges(s, g, c) : concatEdges(s, c, g),
      nodes: "inwards" === n ? concatNodes(d, p) : concatNodes(p, d),
      pageInfo: {
        __typename: y.__typename,
        endCursor: y.endCursor,
        startCursor: y.startCursor,
        hasNextPage: y.hasNextPage,
        hasPreviousPage: y.hasPreviousPage
      }
    };
  };
};

exports.simplePagination = function simplePagination(e) {
  if (void 0 === e) {
    e = {};
  }
  var a = e.offsetArgument;
  if (void 0 === a) {
    a = "skip";
  }
  var n = e.limitArgument;
  if (void 0 === n) {
    n = "limit";
  }
  var t = e.mergeMode;
  if (void 0 === t) {
    t = "after";
  }
  function compareArgs(e, t) {
    for (var s in t) {
      if (s === a || s === n) {
        continue;
      } else if (!(s in e)) {
        return !1;
      }
      var o = e[s];
      var i = t[s];
      if (typeof o != typeof i || "object" != typeof o ? o !== i : r.stringifyVariables(o) !== r.stringifyVariables(i)) {
        return !1;
      }
    }
    for (var f in e) {
      if (f === a || f === n) {
        continue;
      }
      if (!(f in t)) {
        return !1;
      }
    }
    return !0;
  }
  return function(e, r, n, s) {
    var o = s.parentKey;
    var i = s.fieldName;
    var f = n.inspectFields(o).filter((function(e) {
      return e.fieldName === i;
    }));
    var u = f.length;
    if (0 === u) {
      return;
    }
    var v = new Set;
    var l = [];
    var g = null;
    for (var c = 0; c < u; c++) {
      var d = f[c];
      var p = d.fieldKey;
      var y = d.arguments;
      if (null === y || !compareArgs(r, y)) {
        continue;
      }
      var m = n.resolve(o, p);
      var h = y[a];
      if (null === m || 0 === m.length || "number" != typeof h) {
        continue;
      }
      var P = [];
      for (var _ = 0; _ < m.length; _++) {
        var N = m[_];
        if (v.has(N)) {
          continue;
        }
        P.push(N);
        v.add(N);
      }
      if ((!g || h > g) == ("after" === t)) {
        l = l.concat(P);
      } else {
        l = P.concat(l);
      }
      g = h;
    }
    if (n.resolve(o, i, r)) {
      return l;
    } else if (!s.store.schema) {
      return;
    } else {
      s.partial = !0;
      return l;
    }
  };
};
//# sourceMappingURL=urql-exchange-graphcache-extras.js.map
