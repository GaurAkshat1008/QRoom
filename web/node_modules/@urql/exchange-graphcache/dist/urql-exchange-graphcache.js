var e = require("@urql/core");

var t = require("wonka");

var r = require("./7832a774.js");

var i = require("graphql");

function getName(e) {
  return e.name.value;
}

function getFragmentTypeName(e) {
  return e.typeCondition.name.value;
}

function getFieldAlias(e) {
  return e.alias ? e.alias.value : getName(e);
}

function getSelectionSet(e) {
  return e.selectionSet ? e.selectionSet.selections : [];
}

function getTypeCondition(e) {
  return e.typeCondition ? getName(e.typeCondition) : null;
}

function isFieldNode(e) {
  return e.kind === i.Kind.FIELD;
}

function isInlineFragment(e) {
  return e.kind === i.Kind.INLINE_FRAGMENT;
}

function getFieldArguments(e, t) {
  var r = {};
  var n = 0;
  if (e.arguments && e.arguments.length) {
    for (var a = 0, o = e.arguments.length; a < o; a++) {
      var s = e.arguments[a];
      var u = i.valueFromASTUntyped(s.value, t);
      if (null != u) {
        r[getName(s)] = u;
        n++;
      }
    }
  }
  return n > 0 ? r : null;
}

function filterVariables(e, t) {
  if (!t || !e.variableDefinitions) {
    return;
  }
  var r = {};
  for (var i = 0, n = e.variableDefinitions.length; i < n; i++) {
    var a = getName(e.variableDefinitions[i].variable);
    r[a] = t[a];
  }
  return r;
}

function normalizeVariables(e, t) {
  var r = {};
  if (!t) {
    return r;
  }
  if (e.variableDefinitions) {
    for (var n = 0, a = e.variableDefinitions.length; n < a; n++) {
      var o = e.variableDefinitions[n];
      var s = getName(o.variable);
      r[s] = void 0 === t[s] && o.defaultValue ? i.valueFromASTUntyped(o.defaultValue, t) : t[s];
    }
  }
  for (var u in t) {
    if (!(u in r)) {
      r[u] = t[u];
    }
  }
  return r;
}

var n = "\nhttps://bit.ly/2XbVrpR#";

var a = new Set;

var o = [];

function popDebugNode() {
  return o.pop();
}

function pushDebugNode(e, t) {
  var r = "";
  if (t.kind === i.Kind.INLINE_FRAGMENT) {
    r = e ? 'Inline Fragment on "' + e + '"' : "Inline Fragment";
  } else if (t.kind === i.Kind.OPERATION_DEFINITION) {
    r = (t.name ? '"' + t.name.value + '"' : "Unnamed") + " " + t.operation;
  } else if (t.kind === i.Kind.FRAGMENT_DEFINITION) {
    r = '"' + t.name.value + '" Fragment';
  }
  if (r) {
    o.push(r);
  }
}

function getDebugOutput() {
  return o.length ? "\n(Caused At: " + o.join(", ") + ")" : "";
}

function invariant(e, t, r) {
  if (!e) {
    var i = t || "Minfied Error #" + r + "\n";
    if ("production" !== process.env.NODE_ENV) {
      i += getDebugOutput();
    }
    var a = new Error(i + n + r);
    a.name = "Graphcache Error";
    throw a;
  }
}

function warn(e, t) {
  if (!a.has(e)) {
    console.warn(e + getDebugOutput() + n + t);
    a.add(e);
  }
}

function getMainOperation(e) {
  for (var t = 0; t < e.definitions.length; t++) {
    if (e.definitions[t].kind === i.Kind.OPERATION_DEFINITION) {
      return e.definitions[t];
    }
  }
  invariant(!1, "production" !== process.env.NODE_ENV ? "Invalid GraphQL document: All GraphQL documents must contain an OperationDefinitionnode for a query, subscription, or mutation." : "", 1);
}

function getFragments(e) {
  var t = {};
  for (var r = 0; r < e.definitions.length; r++) {
    var n = e.definitions[r];
    if (n.kind === i.Kind.FRAGMENT_DEFINITION) {
      t[getName(n)] = n;
    }
  }
  return t;
}

function shouldInclude(e, t) {
  for (var r = 0; e.directives && r < e.directives.length; r++) {
    var n = e.directives[r];
    var a = getName(n);
    if (("include" === a || "skip" === a) && n.arguments && n.arguments[0] && "if" === getName(n.arguments[0])) {
      var o = i.valueFromASTUntyped(n.arguments[0].value, t);
      return "include" === a ? !!o : !o;
    }
  }
  return !0;
}

function isDeferred(e, t) {
  for (var r = 0; e.directives && r < e.directives.length; r++) {
    var n = e.directives[r];
    if ("defer" === getName(n)) {
      for (var a = 0; n.arguments && a < n.arguments.length; a++) {
        var o = n.arguments[r];
        if ("if" === getName(o)) {
          return !!i.valueFromASTUntyped(o.value, t);
        }
      }
      return !0;
    }
  }
  return !1;
}

function isFieldNullable(e, t, r) {
  var i = getField(e, t, r);
  return !!i && "NON_NULL" !== i.type.kind;
}

function isListNullable(e, t, r) {
  var i = getField(e, t, r);
  if (!i) {
    return !1;
  }
  var n = "NON_NULL" === i.type.kind ? i.type.ofType : i.type;
  return "LIST" === n.kind && "NON_NULL" !== n.ofType.kind;
}

function isFieldAvailableOnType(e, t, r) {
  return 0 === r.indexOf("__") || 0 === t.indexOf("__") || !!getField(e, t, r);
}

function isInterfaceOfType(e, t, r) {
  if (!r) {
    return !1;
  }
  var i = getTypeCondition(t);
  if (!i || r === i) {
    return !0;
  } else if (e.types[i] && "OBJECT" === e.types[i].kind) {
    return i === r;
  }
  !function expectAbstractType(e, t) {
    invariant(e.types[t] && ("INTERFACE" === e.types[t].kind || "UNION" === e.types[t].kind), "production" !== process.env.NODE_ENV ? "Invalid Abstract type: The type `" + t + "` is not an Interface or Union type in the defined schema, but a fragment in the GraphQL document is using it as a type condition." : "", 5);
  }(e, i);
  expectObjectType(e, r);
  return e.isSubType(i, r);
}

function getField(e, t, r) {
  if (0 === r.indexOf("__") || 0 === t.indexOf("__")) {
    return;
  }
  expectObjectType(e, t);
  var i = e.types[t].fields[r];
  if ("production" !== process.env.NODE_ENV) {
    if (!i) {
      warn("Invalid field: The field `" + r + "` does not exist on `" + t + "`, but the GraphQL document expects it to exist.\nTraversal will continue, however this may lead to undefined behavior!", 4);
    }
  }
  return i;
}

function expectObjectType(e, t) {
  invariant(e.types[t] && "OBJECT" === e.types[t].kind, "production" !== process.env.NODE_ENV ? "Invalid Object type: The type `" + t + "` is not an object in the defined schema, but the GraphQL document is traversing it." : "", 3);
}

function warnAboutResolver(e) {
  "production" !== process.env.NODE_ENV && warn("Invalid resolver: `" + e + "` is not in the defined schema, but the `resolvers` option is referencing it.", 23);
}

function keyOfField(t, r) {
  return r ? t + "(" + e.stringifyVariables(r) + ")" : t;
}

function joinKeys(e, t) {
  return e + "." + t;
}

function fieldInfoOfKey(e) {
  var t = e.indexOf("(");
  if (t > -1) {
    return {
      fieldKey: e,
      fieldName: e.slice(0, t),
      arguments: JSON.parse(e.slice(t + 1, -1))
    };
  } else {
    return {
      fieldKey: e,
      fieldName: e,
      arguments: null
    };
  }
}

function deserializeKeyInfo(e) {
  var t = e.indexOf(".");
  return {
    entityKey: e.slice(0, t).replace(/%2e/g, "."),
    fieldKey: e.slice(t + 1)
  };
}

function makeDict() {
  return Object.create(null);
}

var s = null;

var u = null;

var c = null;

var l = null;

var d = null;

var f = null;

var p = !1;

function makeNodeMap() {
  return {
    optimistic: makeDict(),
    base: new Map
  };
}

function makeData(e) {
  var t;
  if (e) {
    if (s.has(e)) {
      return e;
    }
    t = u.get(e) || r._extends({}, e);
    u.set(e, t);
  } else {
    t = {};
  }
  s.add(t);
  return t;
}

function ownsData(e) {
  return !!e && s.has(e);
}

function initDataState(e, t, r, i) {
  s = new Set;
  u = new Map;
  c = e;
  l = t;
  d = makeDict();
  p = !!i;
  if ("production" !== process.env.NODE_ENV) {
    o.length = 0;
  }
  if (!r) {
    f = null;
  } else if (i || t.optimisticOrder.length > 0) {
    if (!i && !t.commutativeKeys.has(r)) {
      reserveLayer(t, r);
    } else if (i) {
      t.commutativeKeys.delete(r);
    }
    f = r;
    !function createLayer(e, t) {
      if (-1 === e.optimisticOrder.indexOf(t)) {
        e.optimisticOrder.unshift(t);
      }
      if (!e.refLock[t]) {
        e.refLock[t] = makeDict();
        e.links.optimistic[t] = new Map;
        e.records.optimistic[t] = new Map;
      }
    }(t, r);
  } else {
    f = null;
    deleteLayer(t, r);
  }
}

function clearDataState() {
  if ("production" !== process.env.NODE_ENV) {
    getCurrentDependencies();
  }
  var t = l;
  var r = f;
  p = !1;
  f = null;
  if (r && t.optimisticOrder.indexOf(r) > -1) {
    var i = t.optimisticOrder.length;
    while (--i >= 0 && t.refLock[t.optimisticOrder[i]] && t.commutativeKeys.has(t.optimisticOrder[i]) && !t.deferredKeys.has(t.optimisticOrder[i])) {
      squashLayer(t.optimisticOrder[i]);
    }
  }
  s = null;
  u = null;
  c = null;
  l = null;
  d = null;
  if ("production" !== process.env.NODE_ENV) {
    o.length = 0;
  }
  if ("test" !== process.env.NODE_ENV && !t.defer) {
    t.defer = !0;
    Promise.resolve().then((function() {
      initDataState("read", t, null);
      !function gc() {
        l.gc.forEach((function(e, t, r) {
          if ((l.refCount[e] || 0) > 0) {
            r.delete(e);
            return;
          }
          for (var i in l.refLock) {
            var n = l.refLock[i];
            if ((n[e] || 0) > 0) {
              return;
            }
            delete n[e];
          }
          delete l.refCount[e];
          r.delete(e);
          l.records.base.delete(e);
          var a = l.links.base.get(e);
          if (a) {
            l.links.base.delete(e);
            for (var o in a) {
              updateRCForLink(r, l.refCount, a[o], -1);
            }
          }
        }));
      }();
      !function persistData() {
        if (l.storage) {
          p = !0;
          c = "read";
          var t = makeDict();
          l.persist.forEach((function(r) {
            var i = deserializeKeyInfo(r);
            var n = i.entityKey;
            var a = i.fieldKey;
            var o;
            if (void 0 !== (o = readLink(n, a))) {
              t[r] = ":" + e.stringifyVariables(o);
            } else if (void 0 !== (o = readRecord(n, a))) {
              t[r] = e.stringifyVariables(o);
            } else {
              t[r] = void 0;
            }
          }));
          p = !1;
          l.storage.writeData(t);
          l.persist.clear();
        }
      }();
      clearDataState();
      t.defer = !1;
    }));
  }
}

function noopDataState(e, t, r) {
  if (t && !r) {
    e.deferredKeys.delete(t);
  }
  initDataState("read", e, t, r);
  clearDataState();
}

function getCurrentOperation() {
  invariant(null !== c, "production" !== process.env.NODE_ENV ? "Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs." : "", 2);
  return c;
}

function getCurrentDependencies() {
  invariant(null !== d, "production" !== process.env.NODE_ENV ? "Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs." : "", 2);
  return d;
}

function setNode(e, t, r, i) {
  var n = f ? e.optimistic[f] : e.base;
  var a = n.get(t);
  if (void 0 === a) {
    n.set(t, a = makeDict());
  }
  if (void 0 === i && !f) {
    delete a[r];
  } else {
    a[r] = i;
  }
}

function getNode(e, t, r) {
  var i;
  var n = !p && "read" === c && f && l.commutativeKeys.has(f);
  for (var a = 0, o = l.optimisticOrder.length; a < o; a++) {
    var s = l.optimisticOrder[a];
    var u = e.optimistic[s];
    n = n && s !== f;
    if (u && (!n || !l.commutativeKeys.has(s)) && (!p || "write" === c || l.commutativeKeys.has(s)) && void 0 !== (i = u.get(t)) && r in i) {
      return i[r];
    }
  }
  return void 0 !== (i = e.base.get(t)) ? i[r] : void 0;
}

function updateRCForEntity(e, t, r, i) {
  var n = void 0 !== t[r] ? t[r] : 0;
  var a = t[r] = n + i | 0;
  if (void 0 !== e) {
    if (a <= 0) {
      e.add(r);
    } else if (n <= 0 && a > 0) {
      e.delete(r);
    }
  }
}

function updateRCForLink(e, t, r, i) {
  if ("string" == typeof r) {
    updateRCForEntity(e, t, r, i);
  } else if (Array.isArray(r)) {
    for (var n = 0, a = r.length; n < a; n++) {
      if (Array.isArray(r[n])) {
        updateRCForLink(e, t, r[n], i);
      } else if (r[n]) {
        updateRCForEntity(e, t, r[n], i);
      }
    }
  }
}

function extractNodeFields(e, t, r) {
  if (void 0 !== r) {
    for (var i in r) {
      if (!t.has(i)) {
        e.push(fieldInfoOfKey(i));
        t.add(i);
      }
    }
  }
}

function extractNodeMapFields(e, t, r, i) {
  extractNodeFields(e, t, i.base.get(r));
  for (var n = 0, a = l.optimisticOrder.length; n < a; n++) {
    var o = i.optimistic[l.optimisticOrder[n]];
    if (void 0 !== o) {
      extractNodeFields(e, t, o.get(r));
    }
  }
}

function updateDependencies(e, t) {
  if ("__typename" !== t) {
    if (e !== l.queryRootKey) {
      d[e] = !0;
    } else if (void 0 !== t) {
      d[joinKeys(e, t)] = !0;
    }
  }
}

function updatePersist(e, t) {
  if (!p && l.storage) {
    l.persist.add(function serializeKeys(e, t) {
      return e.replace(/\./g, "%2e") + "." + t;
    }(e, t));
  }
}

function readRecord(e, t) {
  updateDependencies(e, t);
  return getNode(l.records, e, t);
}

function readLink(e, t) {
  updateDependencies(e, t);
  return getNode(l.links, e, t);
}

function writeRecord(e, t, r) {
  updateDependencies(e, t);
  updatePersist(e, t);
  setNode(l.records, e, t, r);
}

function writeLink(e, t, r) {
  var i = l;
  var n;
  var a;
  var o;
  if (f) {
    n = i.refLock[f] || (i.refLock[f] = makeDict());
    a = i.links.optimistic[f];
  } else {
    n = i.refCount;
    a = i.links.base;
    o = i.gc;
  }
  var s = a && a.get(e);
  var u = s && s[t];
  updateDependencies(e, t);
  updatePersist(e, t);
  setNode(i.links, e, t, r);
  updateRCForLink(o, n, u, -1);
  updateRCForLink(o, n, r, 1);
}

function reserveLayer(e, t, r) {
  var i = e.optimisticOrder.indexOf(t);
  if (-1 === i) {
    e.optimisticOrder.unshift(t);
  } else if (!e.commutativeKeys.has(t)) {
    clearLayer(e, t);
    e.optimisticOrder.splice(i, 1);
    e.optimisticOrder.unshift(t);
  }
  if (r) {
    e.deferredKeys.add(t);
  } else {
    e.deferredKeys.delete(t);
  }
  e.commutativeKeys.add(t);
}

function clearLayer(e, t) {
  if (e.refLock[t]) {
    delete e.refLock[t];
    delete e.records.optimistic[t];
    delete e.links.optimistic[t];
    e.deferredKeys.delete(t);
  }
}

function deleteLayer(e, t) {
  var r = e.optimisticOrder.indexOf(t);
  if (r > -1) {
    e.optimisticOrder.splice(r, 1);
    e.commutativeKeys.delete(t);
  }
  clearLayer(e, t);
}

function squashLayer(e) {
  var t = d;
  d = makeDict();
  var r = l.links.optimistic[e];
  if (r) {
    r.forEach((function(e, t) {
      for (var r in e) {
        writeLink(t, r, e[r]);
      }
    }));
  }
  var i = l.records.optimistic[e];
  if (i) {
    i.forEach((function(e, t) {
      for (var r in e) {
        writeRecord(t, r, e[r]);
      }
    }));
  }
  d = t;
  deleteLayer(l, e);
}

function inspectFields(e) {
  var t = l.links;
  var r = l.records;
  var i = [];
  var n = new Set;
  updateDependencies(e);
  extractNodeMapFields(i, n, e, t);
  extractNodeMapFields(i, n, e, r);
  return i;
}

var v = {
  current: null
};

var y = {
  current: !1
};

function getFieldError(e) {
  return e.__internal.path.length > 0 && e.__internal.errorMap ? e.__internal.errorMap[e.__internal.path.join(".")] : void 0;
}

function makeContext(e, t, r, i, n, a, o) {
  var s = {
    store: e,
    variables: t,
    fragments: r,
    parent: {
      __typename: i
    },
    parentTypeName: i,
    parentKey: n,
    parentFieldKey: "",
    fieldName: "",
    error: void 0,
    partial: !1,
    optimistic: !!a,
    __internal: {
      path: [],
      errorMap: void 0
    }
  };
  if (o && o.graphQLErrors) {
    for (var u = 0; u < o.graphQLErrors.length; u++) {
      var c = o.graphQLErrors[u];
      if (c.path && c.path.length) {
        if (!s.__internal.errorMap) {
          s.__internal.errorMap = Object.create(null);
        }
        s.__internal.errorMap[c.path.join(".")] = c;
      }
    }
  }
  return s;
}

function updateContext(e, t, r, i, n, a) {
  v.current = e;
  e.parent = t;
  e.parentTypeName = r;
  e.parentKey = i;
  e.parentFieldKey = n;
  e.fieldName = a;
  e.error = getFieldError(e);
}

function isFragmentHeuristicallyMatching(e, t, r, i) {
  if (!t) {
    return !1;
  }
  var n = getTypeCondition(e);
  if (!n || t === n) {
    return !0;
  }
  "production" !== process.env.NODE_ENV && warn("Heuristic Fragment Matching: A fragment is trying to match against the `" + t + "` type, but the type condition is `" + n + "`. Since GraphQL allows for interfaces `" + n + "` may be aninterface.\nA schema needs to be defined for this match to be deterministic, otherwise the fragment will be matched heuristically!", 16);
  return !getSelectionSet(e).some((function(e) {
    if (!isFieldNode(e)) {
      return !1;
    }
    var t = keyOfField(getName(e), getFieldArguments(e, i));
    return !function hasField(e, t) {
      return void 0 !== readRecord(e, t) || void 0 !== readLink(e, t);
    }(r, t);
  }));
}

function makeSelectionIterator(e, t, r, i) {
  var n = !1;
  var a;
  var o = 0;
  return function next() {
    if (!y.current && n) {
      y.current = n;
    }
    if (a) {
      var s = a();
      if (null != s) {
        return s;
      }
      a = void 0;
      n = !1;
      if ("production" !== process.env.NODE_ENV) {
        popDebugNode();
      }
    }
    while (o < r.length) {
      var u = r[o++];
      if (!shouldInclude(u, i.variables)) {
        continue;
      } else if (!isFieldNode(u)) {
        var c = !isInlineFragment(u) ? i.fragments[getName(u)] : u;
        if (void 0 !== c) {
          if (i.store.schema ? isInterfaceOfType(i.store.schema, c, e) : isFragmentHeuristicallyMatching(c, e, t, i.variables)) {
            if ("production" !== process.env.NODE_ENV) {
              pushDebugNode(e, c);
            }
            n = !!isDeferred(u, i.variables);
            if (!y.current && n) {
              y.current = n;
            }
            return (a = makeSelectionIterator(e, t, getSelectionSet(c), i))();
          }
        }
      } else {
        return u;
      }
    }
  };
}

function ensureData(e) {
  return null == e ? null : e;
}

function ensureLink(e, t) {
  if (null == t) {
    return t;
  } else if (Array.isArray(t)) {
    var r = new Array(t.length);
    for (var i = 0, n = r.length; i < n; i++) {
      r[i] = ensureLink(e, t[i]);
    }
    return r;
  }
  var a = e.keyOfEntity(t);
  if ("production" !== process.env.NODE_ENV) {
    if (!a && t && "object" == typeof t) {
      warn("Can't generate a key for link(...) item.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + t.__typename + "`.", 12);
    }
  }
  return a;
}

function write(e, t, r, i, n) {
  initDataState("write", e.data, n || null);
  var a = startWrite(e, t, r, i);
  clearDataState();
  return a;
}

function startWrite(e, t, r, i, n) {
  var a = getMainOperation(t.query);
  var o = {
    data: r,
    dependencies: getCurrentDependencies()
  };
  var s = e.rootFields[a.operation];
  var u = makeContext(e, normalizeVariables(a, t.variables), getFragments(t.query), s, s, !!n, i);
  if ("production" !== process.env.NODE_ENV) {
    pushDebugNode(s, a);
  }
  writeSelection(u, s, getSelectionSet(a), r);
  if ("production" !== process.env.NODE_ENV) {
    popDebugNode();
  }
  return o;
}

function writeSelection(e, t, r, i) {
  var n = t === e.store.rootFields.query;
  var a = !n && !!e.store.rootNames[t];
  var o = a || n ? t : i.__typename;
  if (!o) {
    "production" !== process.env.NODE_ENV && warn("Couldn't find __typename when writing.\nIf you're writing to the cache manually have to pass a `__typename` property on each entity in your data.", 14);
    return;
  } else if (!a && !n && t) {
    writeRecord(t, "__typename", o);
  }
  var s = makeSelectionIterator(o, t || o, r, e);
  var u;
  while (u = s()) {
    var c = getName(u);
    var l = getFieldArguments(u, e.variables);
    var d = keyOfField(c, l);
    var f = getFieldAlias(u);
    var p = i[f];
    if ("production" !== process.env.NODE_ENV) {
      if (!a && void 0 === p && !y.current) {
        "production" !== process.env.NODE_ENV && warn("Invalid undefined: The field at `" + d + "` is `undefined`, but the GraphQL query expects a " + (void 0 === u.selectionSet ? "scalar (number, boolean, etc)" : "selection set") + " for this field." + (e.optimistic ? "\nYour optimistic result may be missing a field!" : ""), 13);
        continue;
      } else if (e.store.schema && o && "__typename" !== c) {
        isFieldAvailableOnType(e.store.schema, o, c);
      }
    }
    if ("__typename" === c || void 0 === p && y.current) {
      continue;
    }
    e.__internal.path.push(f);
    if (e.optimistic && a) {
      var v = e.store.optimisticMutations[c];
      if (!v) {
        continue;
      }
      updateContext(e, i, o, o, d, c);
      p = i[f] = ensureData(v(l || {}, e.store, e));
    }
    if (u.selectionSet) {
      if (t && !a) {
        var m = joinKeys(t, d);
        writeLink(t || o, d, writeField(e, getSelectionSet(u), ensureData(p), m));
      } else {
        writeField(e, getSelectionSet(u), ensureData(p));
      }
    } else if (t && !a) {
      writeRecord(t || o, d, null !== p || !getFieldError(e) ? p : void 0);
    }
    if (a) {
      var h = e.store.updates[o][c];
      if (h) {
        updateContext(e, i, o, o, joinKeys(o, d), c);
        i[c] = p;
        h(i, l || {}, e.store, e);
      }
    }
    e.__internal.path.pop();
  }
}

var m = /^__|PageInfo|(Connection|Edge)$/;

function writeField(e, t, r, i) {
  if (Array.isArray(r)) {
    var n = new Array(r.length);
    for (var a = 0, o = r.length; a < o; a++) {
      e.__internal.path.push(a);
      var s = i ? joinKeys(i, "" + a) : void 0;
      var u = writeField(e, t, r[a], s);
      n[a] = u;
      e.__internal.path.pop();
    }
    return n;
  } else if (null === r) {
    return getFieldError(e) ? void 0 : null;
  }
  var c = e.store.keyOfEntity(r);
  var l = r.__typename;
  if ("production" !== process.env.NODE_ENV) {
    if (i && !e.store.keys[r.__typename] && null === c && "string" == typeof l && !m.test(l)) {
      warn("Invalid key: The GraphQL query at the field at `" + i + "` has a selection set, but no key could be generated for the data at this field.\nYou have to request `id` or `_id` fields for all selection sets or create a custom `keys` config for `" + l + "`.\nEntities without keys will be embedded directly on the parent entity. If this is intentional, create a `keys` config for `" + l + "` that always returns null.", 15);
    }
  }
  var d = c || i;
  writeSelection(e, d, t, r);
  return d || null;
}

function Store(e) {
  var t, r;
  this.keyOfField = keyOfField;
  this.resolveFieldByKey = this.resolve;
  if (!e) {
    e = {};
  }
  this.resolvers = e.resolvers || {};
  this.optimisticMutations = e.optimistic || {};
  this.keys = e.keys || {};
  var i = "Query";
  var n = "Mutation";
  var a = "Subscription";
  if (e.schema) {
    var o = function buildClientSchema(e) {
      var t = e.__schema;
      var r = {};
      function buildNameMap(e) {
        var t = {};
        for (var r = 0; r < e.length; r++) {
          t[e[r].name] = e[r];
        }
        return t;
      }
      function buildType(e) {
        switch (e.kind) {
         case "OBJECT":
         case "INTERFACE":
          return {
            name: e.name,
            kind: e.kind,
            interfaces: buildNameMap(e.interfaces || []),
            fields: buildNameMap(e.fields.map((function(e) {
              return {
                name: e.name,
                type: e.type,
                args: buildNameMap(e.args)
              };
            })))
          };

         case "UNION":
          return {
            name: e.name,
            kind: e.kind,
            types: buildNameMap(e.possibleTypes || [])
          };
        }
      }
      var i = {
        query: t.queryType ? t.queryType.name : null,
        mutation: t.mutationType ? t.mutationType.name : null,
        subscription: t.subscriptionType ? t.subscriptionType.name : null,
        types: void 0,
        isSubType: function isSubType(e, t) {
          var i = r[e];
          var n = r[t];
          if (!i || !n) {
            return !1;
          } else if ("UNION" === i.kind) {
            return !!i.types[t];
          } else if ("OBJECT" !== i.kind && "OBJECT" === n.kind) {
            return !!n.interfaces[e];
          } else {
            return e === t;
          }
        }
      };
      if (t.types) {
        i.types = r;
        for (var n = 0; n < t.types.length; n++) {
          var a = t.types[n];
          if (a && a.name) {
            var o = buildType(a);
            if (o) {
              r[a.name] = o;
            }
          }
        }
      }
      return i;
    }(e.schema);
    i = o.query || i;
    n = o.mutation || n;
    a = o.subscription || a;
    if (o.types) {
      this.schema = o;
    }
  }
  this.updates = ((t = {})[n] = e.updates && e.updates.Mutation || {}, t[a] = e.updates && e.updates.Subscription || {}, 
  t);
  this.rootFields = {
    query: i,
    mutation: n,
    subscription: a
  };
  this.rootNames = ((r = {})[i] = "query", r[n] = "mutation", r[a] = "subscription", 
  r);
  this.data = function make(e) {
    return {
      defer: !1,
      gc: new Set,
      persist: new Set,
      queryRootKey: e,
      refCount: makeDict(),
      refLock: makeDict(),
      links: makeNodeMap(),
      records: makeNodeMap(),
      deferredKeys: new Set,
      commutativeKeys: new Set,
      optimisticOrder: [],
      storage: null
    };
  }(i);
  if (this.schema && "production" !== process.env.NODE_ENV) {
    !function expectValidKeyingConfig(e, t) {
      if ("production" !== process.env.NODE_ENV) {
        for (var r in t) {
          if ("production" !== process.env.NODE_ENV) {
            if (!e.types[r]) {
              warn("Invalid Object type: The type `" + r + "` is not an object in the defined schema, but the `keys` option is referencing it.", 20);
            }
          }
        }
      }
    }(this.schema, this.keys);
    !function expectValidUpdatesConfig(e, t) {
      if ("production" === process.env.NODE_ENV) {
        return;
      }
      if (e.mutation) {
        var r = e.types[e.mutation].fields;
        var i = t[e.mutation] || {};
        for (var n in i) {
          if ("production" !== process.env.NODE_ENV) {
            if (void 0 === r[n]) {
              warn("Invalid mutation field: `" + n + "` is not in the defined schema, but the `updates.Mutation` option is referencing it.", 21);
            }
          }
        }
      }
      if (e.subscription) {
        var a = e.types[e.subscription].fields;
        var o = t[e.subscription] || {};
        for (var s in o) {
          if ("production" !== process.env.NODE_ENV) {
            if (void 0 === a[s]) {
              warn("Invalid subscription field: `" + s + "` is not in the defined schema, but the `updates.Subscription` option is referencing it.", 22);
            }
          }
        }
      }
    }(this.schema, this.updates);
    !function expectValidResolversConfig(e, t) {
      if ("production" === process.env.NODE_ENV) {
        return;
      }
      for (var r in t) {
        if ("Query" === r) {
          if (e.query) {
            var i = e.types[e.query].fields;
            for (var n in t.Query) {
              if (!i[n]) {
                warnAboutResolver("Query." + n);
              }
            }
          } else {
            warnAboutResolver("Query");
          }
        } else if (!e.types[r]) {
          warnAboutResolver(r);
        } else if ("INTERFACE" === e.types[r].kind || "UNION" === e.types[r].kind) {
          s = r, u = e.types[r].kind, "production" !== process.env.NODE_ENV && warn("Invalid resolver: `" + s + "` does not match to a concrete type in the schema, but the `resolvers` option is referencing it. Implement the resolver for the types that " + ("UNION" === u ? "make up the union" : "implement the interface") + " instead.", 26);
        } else {
          var a = e.types[r].fields;
          for (var o in t[r]) {
            if (!a[o]) {
              warnAboutResolver(r + "." + o);
            }
          }
        }
      }
      var s, u;
    }(this.schema, this.resolvers);
    !function expectValidOptimisticMutationsConfig(e, t) {
      if ("production" === process.env.NODE_ENV) {
        return;
      }
      if (e.mutation) {
        var r = e.types[e.mutation].fields;
        for (var i in t) {
          if ("production" !== process.env.NODE_ENV) {
            if (!r[i]) {
              warn("Invalid optimistic mutation field: `" + i + "` is not a mutation field in the defined schema, but the `optimistic` option is referencing it.", 24);
            }
          }
        }
      }
    }(this.schema, this.optimisticMutations);
  }
}

Store.prototype.keyOfEntity = function keyOfEntity(e) {
  if (v.current && e === v.current.parent) {
    return v.current.parentKey;
  }
  if (null == e || "string" == typeof e) {
    return e || null;
  }
  if (!e.__typename) {
    return null;
  }
  if (this.rootNames[e.__typename]) {
    return e.__typename;
  }
  var t;
  if (this.keys[e.__typename]) {
    t = this.keys[e.__typename](e);
  } else if (null != e.id) {
    t = "" + e.id;
  } else if (null != e._id) {
    t = "" + e._id;
  }
  return t ? e.__typename + ":" + t : null;
};

Store.prototype.resolve = function resolve(e, t, r) {
  var i = keyOfField(t, r);
  var n = this.keyOfEntity(e);
  if (!n) {
    return null;
  }
  var a = readRecord(n, i);
  if (void 0 !== a) {
    return a;
  }
  return readLink(n, i) || null;
};

Store.prototype.invalidate = function invalidate(e, t, r) {
  var i = this.keyOfEntity(e);
  invariant(i, "production" !== process.env.NODE_ENV ? "Can't generate a key for invalidate(...).\nYou have to pass an id or _id field or create a custom `keys` field for `" + typeof e == "object" ? e.__typename : e + "`." : "", 19);
  !function invalidateEntity(e, t, r) {
    var i = t ? [ {
      fieldKey: keyOfField(t, r)
    } ] : inspectFields(e);
    for (var n = 0, a = i.length; n < a; n++) {
      var o = i[n].fieldKey;
      if (void 0 !== readLink(e, o)) {
        writeLink(e, o, void 0);
      } else {
        writeRecord(e, o, void 0);
      }
    }
  }(i, t, r);
};

Store.prototype.inspectFields = function inspectFields$1(e) {
  var t = this.keyOfEntity(e);
  return t ? inspectFields(t) : [];
};

Store.prototype.updateQuery = function updateQuery(t, r) {
  var i = e.createRequest(t.query, t.variables);
  i.query = e.formatDocument(i.query);
  var n = r(this.readQuery(i));
  if (null !== n) {
    startWrite(this, i, n);
  }
};

Store.prototype.readQuery = function readQuery(t) {
  var r = e.createRequest(t.query, t.variables);
  r.query = e.formatDocument(r.query);
  return read(this, r).data;
};

Store.prototype.readFragment = function readFragment$1(t, r, i) {
  return function readFragment(e, t, r, i) {
    var n = getFragments(t);
    var a = Object.keys(n);
    var o = n[a[0]];
    if (!o) {
      "production" !== process.env.NODE_ENV && warn("readFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 6);
      return null;
    }
    var s = getFragmentTypeName(o);
    if ("string" != typeof r && !r.__typename) {
      r.__typename = s;
    }
    var u = e.keyOfEntity(r);
    if (!u) {
      "production" !== process.env.NODE_ENV && warn("Can't generate a key for readFragment(...).\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + s + "`.", 7);
      return null;
    }
    if ("production" !== process.env.NODE_ENV) {
      pushDebugNode(s, o);
    }
    var c = readSelection(makeContext(e, i || {}, n, s, u), u, getSelectionSet(o), makeData()) || null;
    if ("production" !== process.env.NODE_ENV) {
      popDebugNode();
    }
    return c;
  }(this, e.formatDocument(t), r, i);
};

Store.prototype.writeFragment = function writeFragment$1(t, i, n) {
  !function writeFragment(e, t, i, n) {
    var a = getFragments(t);
    var o = a[Object.keys(a)[0]];
    if (!o) {
      return "production" !== process.env.NODE_ENV ? warn("writeFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 11) : void 0;
    }
    var s = getFragmentTypeName(o);
    var u = r._extends({}, {
      __typename: s
    }, i);
    var c = e.keyOfEntity(u);
    if (!c) {
      return "production" !== process.env.NODE_ENV ? warn("Can't generate a key for writeFragment(...) data.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + s + "`.", 12) : void 0;
    }
    if ("production" !== process.env.NODE_ENV) {
      pushDebugNode(s, o);
    }
    writeSelection(makeContext(e, n || {}, a, s, c, void 0), c, getSelectionSet(o), u);
    if ("production" !== process.env.NODE_ENV) {
      popDebugNode();
    }
  }(this, e.formatDocument(t), i, n);
};

Store.prototype.link = function link(e, t, r, i) {
  var n = void 0 !== i ? r : null;
  var link = void 0 !== i ? i : r;
  var a = ensureLink(this, e);
  if ("string" == typeof a) {
    writeLink(a, keyOfField(t, n), ensureLink(this, link));
  }
};

function query(e, t, r, i, n) {
  initDataState("read", e.data, n);
  var a = read(e, t, r, i);
  clearDataState();
  return a;
}

function read(e, t, r, i) {
  var n = getMainOperation(t.query);
  var a = e.rootFields[n.operation];
  var o = getSelectionSet(n);
  var s = makeContext(e, normalizeVariables(n, t.variables), getFragments(t.query), a, a, !1, i);
  if ("production" !== process.env.NODE_ENV) {
    pushDebugNode(a, n);
  }
  if (!r) {
    r = makeData();
  }
  var u = a !== s.store.rootFields.query ? readRoot(s, a, o, r) : readSelection(s, a, o, r);
  if ("production" !== process.env.NODE_ENV) {
    popDebugNode();
  }
  return {
    dependencies: getCurrentDependencies(),
    partial: s.partial || !u,
    data: u || null
  };
}

function readRoot(e, t, r, i) {
  if ("string" != typeof (e.store.rootNames[t] ? t : i.__typename)) {
    return i;
  }
  var n = makeSelectionIterator(t, t, r, e);
  var a;
  var o = !1;
  var s = makeData(i);
  while (a = n()) {
    var u = getFieldAlias(a);
    var c = i[u];
    e.__internal.path.push(u);
    var l = void 0;
    if (a.selectionSet && null !== c) {
      l = readRootField(e, getSelectionSet(a), ensureData(c));
    } else {
      l = c;
    }
    o = o || l !== c;
    if (void 0 !== l) {
      s[u] = l;
    }
    e.__internal.path.pop();
  }
  return o ? s : i;
}

function readRootField(e, t, r) {
  if (Array.isArray(r)) {
    var i = new Array(r.length);
    var n = !1;
    for (var a = 0, o = r.length; a < o; a++) {
      e.__internal.path.push(a);
      i[a] = readRootField(e, t, r[a]);
      n = n || i[a] !== r[a];
      e.__internal.path.pop();
    }
    return n ? i : r;
  } else if (null === r) {
    return null;
  }
  var s = e.store.keyOfEntity(r);
  if (null !== s) {
    return readSelection(e, s, t, r) || null;
  } else {
    return readRoot(e, r.__typename, t, r);
  }
}

function readSelection(e, t, r, i, n) {
  var a = e.store;
  var o = t === a.rootFields.query;
  var s = n && a.keyOfEntity(n) || t;
  if ("production" !== process.env.NODE_ENV) {
    if (!o && e.store.rootNames[s]) {
      warn("Invalid root traversal: A selection was being read on `" + s + "` which is an uncached root type.\nThe `" + e.store.rootFields.mutation + "` and `" + e.store.rootFields.subscription + "` types are special Operation Root Types and cannot be read back from the cache.", 25);
    }
  }
  var u = !o ? readRecord(s, "__typename") || n && n.__typename : t;
  if ("string" != typeof u) {
    return;
  } else if (n && u !== n.__typename) {
    "production" !== process.env.NODE_ENV && warn("Invalid resolver data: The resolver at `" + s + "` returned an invalid typename that could not be reconciled with the cache.", 8);
    return;
  }
  var c = makeSelectionIterator(u, s, r, e);
  var l = !1;
  var d = !1;
  var f = u !== i.__typename;
  var p;
  var v = makeData(i);
  while (void 0 !== (p = c())) {
    var m = getName(p);
    var h = getFieldArguments(p, e.variables);
    var g = getFieldAlias(p);
    var N = keyOfField(m, h);
    var k = joinKeys(s, N);
    var O = readRecord(s, N);
    var _ = n ? n[m] : void 0;
    var E = a.resolvers[u];
    if ("production" !== process.env.NODE_ENV && a.schema && u) {
      isFieldAvailableOnType(a.schema, u, m);
    }
    e.__internal.path.push(g);
    var b = void 0;
    if ("__typename" === m) {
      b = u;
    } else if (void 0 !== _ && void 0 === p.selectionSet) {
      b = _;
    } else if ("read" === getCurrentOperation() && E && "function" == typeof E[m]) {
      updateContext(e, v, u, s, k, m);
      if (void 0 !== O) {
        v[g] = O;
      }
      b = E[m](v, h || {}, a, e);
      if (p.selectionSet) {
        b = resolveResolverResult(e, u, m, k, getSelectionSet(p), void 0 !== v[g] ? v[g] : i[g], b, ownsData(i));
      }
      if (a.schema && null === b && !isFieldNullable(a.schema, u, m)) {
        return;
      }
    } else if (!p.selectionSet) {
      b = O;
    } else if (void 0 !== _) {
      b = resolveResolverResult(e, u, m, k, getSelectionSet(p), void 0 !== v[g] ? v[g] : i[g], _, ownsData(i));
    } else {
      var D = readLink(s, N);
      if (void 0 !== D) {
        b = resolveLink(e, D, u, m, getSelectionSet(p), void 0 !== v[g] ? v[g] : i[g], ownsData(i));
      } else if ("object" == typeof O && null !== O) {
        b = O;
      }
    }
    if (void 0 === b && y.current) {
      l = !0;
    } else if (void 0 === b && (a.schema && isFieldNullable(a.schema, u, m) || getFieldError(e))) {
      d = !0;
      b = null;
    } else if (void 0 === b) {
      e.__internal.path.pop();
      return;
    } else {
      l = l || "__typename" !== m;
    }
    e.__internal.path.pop();
    f = f || b !== i[g];
    if (void 0 !== b) {
      v[g] = b;
    }
  }
  e.partial = e.partial || d;
  return o && d && !l ? void 0 : f ? v : i;
}

function resolveResolverResult(e, t, r, i, n, a, o, s) {
  if (Array.isArray(o)) {
    var u = e.store;
    var c = u.schema ? isListNullable(u.schema, t, r) : !1;
    var l = new Array(o.length);
    var d = !Array.isArray(a) || o.length !== a.length;
    for (var f = 0, p = o.length; f < p; f++) {
      e.__internal.path.push(f);
      var v = resolveResolverResult(e, t, r, joinKeys(i, "" + f), n, null != a ? a[f] : void 0, o[f], s);
      e.__internal.path.pop();
      if (void 0 === v && !c) {
        return;
      } else {
        e.partial = e.partial || void 0 === v && c;
        l[f] = null != v ? v : null;
        d = d || l[f] !== a[f];
      }
    }
    return d ? l : a;
  } else if (null == o) {
    return o;
  } else if (s && null === a) {
    return null;
  } else if (function isDataOrKey(e) {
    return "string" == typeof e || "object" == typeof e && "string" == typeof e.__typename;
  }(o)) {
    var y = a || makeData();
    return "string" == typeof o ? readSelection(e, o, n, y) : readSelection(e, i, n, y, o);
  } else {
    "production" !== process.env.NODE_ENV && warn("Invalid resolver value: The field at `" + i + "` is a scalar (number, boolean, etc), but the GraphQL query expects a selection set for this field.", 9);
    return;
  }
}

function resolveLink(e, t, r, i, n, a, o) {
  if (Array.isArray(t)) {
    var s = e.store;
    var u = s.schema ? isListNullable(s.schema, r, i) : !1;
    var c = new Array(t.length);
    var l = !Array.isArray(a) || c.length !== a.length;
    for (var d = 0, f = t.length; d < f; d++) {
      e.__internal.path.push(d);
      var p = resolveLink(e, t[d], r, i, n, null != a ? a[d] : void 0, o);
      e.__internal.path.pop();
      if (void 0 === p && !u) {
        return;
      } else {
        e.partial = e.partial || void 0 === p && u;
        c[d] = p || null;
        l = l || c[d] !== a[d];
      }
    }
    return l ? c : a;
  } else if (null === t || null === a && o) {
    return null;
  }
  return readSelection(e, t, n, a || makeData());
}

function addCacheOutcome(t, i) {
  return e.makeOperation(t.kind, t, r._extends({}, t.context, {
    meta: r._extends({}, t.context.meta, {
      cacheOutcome: i
    })
  }));
}

function toRequestPolicy(t, i) {
  return e.makeOperation(t.kind, t, r._extends({}, t.context, {
    requestPolicy: i
  }));
}

function cacheExchange(r) {
  return function(i) {
    var n = i.forward;
    var a = i.client;
    var o = i.dispatchDebug;
    var s = new Store(r);
    var u;
    if (r && r.storage) {
      u = r.storage.readData().then((function(e) {
        !function hydrateData(e, t, r) {
          initDataState("write", e, null);
          for (var i in r) {
            var n = r[i];
            if (void 0 !== n) {
              var a = deserializeKeyInfo(i);
              var o = a.entityKey;
              var s = a.fieldKey;
              if (":" === n[0]) {
                writeLink(o, s, JSON.parse(n.slice(1)));
              } else {
                writeRecord(o, s, JSON.parse(n));
              }
            }
          }
          clearDataState();
          e.storage = t;
        }(s.data, r.storage, e);
      }));
    }
    var c = new Map;
    var l = [];
    var d = new Map;
    var f = new Map;
    var p = makeDict();
    var v = new Set;
    var y = makeDict();
    function isBlockedByOptimisticUpdate(e) {
      for (var t in e) {
        if (p[t]) {
          return !0;
        }
      }
      return !1;
    }
    function collectPendingOperations(e, t) {
      if (t) {
        for (var r in t) {
          var i = y[r];
          if (i) {
            y[r] = [];
            for (var n = 0, a = i.length; n < a; n++) {
              e.add(i[n]);
            }
          }
        }
      }
    }
    function executePendingOperations(e, t) {
      t.forEach((function(t) {
        if (t !== e.key) {
          var r = d.get(t);
          if (r) {
            d.delete(t);
            var i = "cache-first";
            if (v.has(t)) {
              v.delete(t);
              i = "cache-and-network";
            }
            a.reexecuteOperation(toRequestPolicy(r, i));
          }
        }
      }));
    }
    function prepareForwardedOperation(t) {
      if ("query" === t.kind) {
        reserveLayer(s.data, t.key);
      } else if ("teardown" === t.kind) {
        d.delete(t.key);
        f.delete(t.key);
        noopDataState(s.data, t.key);
      } else if ("mutation" === t.kind && "network-only" !== t.context.requestPolicy) {
        var r = function writeOptimistic(e, t, r) {
          if ("production" !== process.env.NODE_ENV) {
            invariant("mutation" === getMainOperation(t.query).operation, "production" !== process.env.NODE_ENV ? "writeOptimistic(...) was called with an operation that is not a mutation.\nThis case is unsupported and should never occur." : "", 10);
          }
          initDataState("write", e.data, r, !0);
          var i = startWrite(e, t, {}, void 0, !0);
          clearDataState();
          return i;
        }(s, t, t.key).dependencies;
        if (!function isDictEmpty(e) {
          for (var t in e) {
            return !1;
          }
          return !0;
        }(r)) {
          for (var i in r) {
            p[i] = !0;
          }
          c.set(t.key, r);
          var n = new Set;
          collectPendingOperations(n, r);
          executePendingOperations(t, n);
        }
      }
      return e.makeOperation(t.kind, {
        key: t.key,
        query: e.formatDocument(t.query),
        variables: t.variables ? filterVariables(getMainOperation(t.query), t.variables) : t.variables
      }, t.context);
    }
    function updateDependencies(e, t) {
      for (var r in t) {
        (y[r] || (y[r] = [])).push(e.key);
        d.set(e.key, e);
      }
    }
    function operationResultFromCache(e) {
      var t = query(s, e, f.get(e.key));
      var r = t.data ? !t.partial ? "hit" : "partial" : "miss";
      f.set(e.key, t.data);
      updateDependencies(e, t.dependencies);
      return {
        outcome: r,
        operation: e,
        data: t.data,
        dependencies: t.dependencies
      };
    }
    function updateCacheWithResult(e, t) {
      var r = e.operation;
      var i = e.error;
      var n = e.extensions;
      var a = r.key;
      if ("mutation" === r.kind) {
        collectPendingOperations(t, c.get(a));
        c.delete(a);
      }
      reserveLayer(s.data, r.key, e.hasNext);
      var o;
      var u = e.data;
      if (u) {
        collectPendingOperations(t, write(s, r, u, e.error, a).dependencies);
        var l = query(s, r, "query" === r.kind ? f.get(r.key) || u : u, e.error, a);
        u = l.data;
        if ("query" === r.kind) {
          collectPendingOperations(t, o = l.dependencies);
          f.set(r.key, e.data);
        }
      } else {
        noopDataState(s.data, r.key);
      }
      if (o) {
        updateDependencies(e.operation, o);
      }
      return {
        data: u,
        error: i,
        extensions: n,
        operation: r
      };
    }
    return function(e) {
      var r = t.share(e);
      var i = u ? t.share(t.merge([ t.mergeMap(t.fromArray)(t.buffer(t.fromPromise(u))(r)), t.skipUntil(t.fromPromise(u))(r) ])) : r;
      var d = t.share(t.map(operationResultFromCache)(t.filter((function(e) {
        return "query" === e.kind && "network-only" !== e.context.requestPolicy;
      }))(i)));
      var f = t.filter((function(e) {
        return "query" !== e.kind || "network-only" === e.context.requestPolicy;
      }))(i);
      var y = t.map((function(e) {
        "production" !== process.env.NODE_ENV && o({
          type: "cacheMiss",
          message: "The result could not be retrieved from the cache",
          operation: e.operation,
          source: "cacheExchange"
        });
        return addCacheOutcome(e.operation, "miss");
      }))(t.filter((function(e) {
        return "miss" === e.outcome && "cache-only" !== e.operation.context.requestPolicy && !isBlockedByOptimisticUpdate(e.dependencies);
      }))(d));
      var m = t.map((function(e) {
        var t = e.operation;
        var r = e.outcome;
        var i = e.dependencies;
        var n = {
          operation: addCacheOutcome(t, r),
          data: e.data,
          error: e.error,
          extensions: e.extensions
        };
        if ("cache-and-network" === t.context.requestPolicy || "cache-first" === t.context.requestPolicy && "partial" === r) {
          n.stale = !0;
          if (!isBlockedByOptimisticUpdate(i)) {
            a.reexecuteOperation(toRequestPolicy(t, "network-only"));
          } else if ("cache-and-network" === t.context.requestPolicy) {
            v.add(t.key);
          }
        }
        "production" !== process.env.NODE_ENV && o({
          type: "cacheHit",
          message: "A requested operation was found and returned from the cache.",
          operation: e.operation,
          data: {
            value: n
          },
          source: "cacheExchange"
        });
        return n;
      }))(t.filter((function(e) {
        return "miss" !== e.outcome || "cache-only" === e.operation.context.requestPolicy;
      }))(d));
      var h = t.share(n(t.map(prepareForwardedOperation)(t.merge([ f, y ]))));
      var g = t.map((function(e) {
        var t = new Set;
        var r = updateCacheWithResult(e, t);
        executePendingOperations(e.operation, t);
        return r;
      }))(t.filter((function(e) {
        return !c.has(e.operation.key);
      }))(h));
      var N = t.mergeMap((function(e) {
        if (l.push(e) < c.size) {
          return t.empty;
        }
        for (var r = 0; r < l.length; r++) {
          reserveLayer(s.data, l[r].operation.key);
        }
        for (var i in p) {
          delete p[i];
        }
        var n = [];
        var a = new Set;
        var o;
        while (o = l.shift()) {
          n.push(updateCacheWithResult(o, a));
        }
        executePendingOperations(e.operation, a);
        return t.fromArray(n);
      }))(t.filter((function(e) {
        return c.has(e.operation.key);
      }))(h));
      return t.merge([ g, N, m ]);
    };
  };
}

function isOfflineError(e) {
  return e && e.networkError && !e.response && ("undefined" != typeof navigator && !1 === navigator.onLine || /request failed|failed to fetch|network\s?error/i.test(e.networkError.message));
}

exports.Store = Store;

exports.cacheExchange = cacheExchange;

exports.offlineExchange = function offlineExchange(r) {
  return function(n) {
    var a = r.storage;
    if (a && a.onOnline && a.readMetadata && a.writeMetadata) {
      var o = n.forward;
      var s = n.client;
      var u = n.dispatchDebug;
      var c = t.makeSubject();
      var l = c.source;
      var d = c.next;
      var f = r.optimistic || {};
      var p = [];
      var updateMetadata = function() {
        var e = [];
        for (var t = 0; t < p.length; t++) {
          var r = p[t];
          if ("mutation" === r.kind) {
            e.push({
              query: i.print(r.query),
              variables: r.variables
            });
          }
        }
        a.writeMetadata(e);
      };
      var v = !1;
      var flushQueue = function() {
        if (!v) {
          v = !0;
          for (var t = 0; t < p.length; t++) {
            var r = p[t];
            if ("mutation" === r.kind) {
              d(e.makeOperation("teardown", r));
            }
          }
          for (var i = 0; i < p.length; i++) {
            s.reexecuteOperation(p[i]);
          }
          p.length = 0;
          v = !1;
          updateMetadata();
        }
      };
      a.onOnline(flushQueue);
      a.readMetadata().then((function(t) {
        if (t) {
          for (var r = 0; r < t.length; r++) {
            p.push(s.createRequestOperation("mutation", e.createRequest(t[r].query, t[r].variables)));
          }
          flushQueue();
        }
      }));
      var y = cacheExchange(r)({
        client: s,
        dispatchDebug: u,
        forward: function(e) {
          return t.filter((function(e) {
            if ("mutation" === e.operation.kind && isOfflineError(e.error) && function isOptimisticMutation(e, t) {
              var r = t.variables || makeDict();
              var i = getFragments(t.query);
              var n = [].concat(getSelectionSet(getMainOperation(t.query)));
              var a;
              while (a = n.pop()) {
                if (!shouldInclude(a, r)) {
                  continue;
                } else if (!isFieldNode(a)) {
                  var o = !isInlineFragment(a) ? i[getName(a)] : a;
                  if (o) {
                    n.push.apply(n, getSelectionSet(o));
                  }
                } else if (e[getName(a)]) {
                  return !0;
                }
              }
              return !1;
            }(f, e.operation)) {
              p.push(e.operation);
              updateMetadata();
              return !1;
            }
            return !0;
          }))(o(e));
        }
      });
      return function(e) {
        var r = t.share(e);
        var i = t.merge([ l, r ]);
        return t.filter((function(e) {
          if ("query" === e.operation.kind && isOfflineError(e.error)) {
            d(toRequestPolicy(e.operation, "cache-only"));
            p.push(e.operation);
            return !1;
          }
          return !0;
        }))(y(i));
      };
    }
    return cacheExchange(r)(n);
  };
};

exports.query = query;

exports.write = write;
//# sourceMappingURL=urql-exchange-graphcache.js.map
